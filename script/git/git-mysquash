#!/bin/zsh
SUBDIRECTORY_OK=true
. "$(git --exec-path)/git-sh-setup" ""
require_clean_work_tree "mysquash" "Please commit or stash them"
cd_to_toplevel

SVN=
GO=
FROM=
PULL=true
PUSH=true
SKIPSQUASH=

help() {
  echo "git-mysquash [-svn|-g|-nopush|-nopull] branch upstream"
  echo "git-mysquash [-svn|-g|-nopush|-nopull] [-to] upstream"
  echo "git-mysquash [-svn|-g|-nopush|-nopull] -from branch"
  echo "Squash branch on top of upstream"
  echo "  (use HEAD for branch/upstream by default if one is not specified,
  use svn for upstream by default if |-svn| is used)
  1) pull upstream
  2) merge upstream in branch
  3) squash merge branch in upstream
  4) merge the squash in branch
  5) push upstream
  |-g|: don't edit commit
  |-svn|: use git-svn for pulling/pushing upstream
  |-nopull/-nopush|: don't do (1) resp (5)
  |-nosquash|: don't do (3)-(5)
  "
  exit 0
}

while true;
do
  case "$1" in
    -- ) shift; break ;;
    -nopull ) shift; PULL= ;;
    -nopush ) shift; PUSH= ;;
    -nosquash ) shift; SKIPSQUASH=1 ;;
    -svn ) shift; SVN="true";;
    -g|-go ) shift; GO="true" ;;
    -from ) shift; FROM="true" ;;
    -to ) shift; FROM= ;;
    -h|-help) shift; help ;;
    *) break;;
  esac
done


CURRENT=$(git current-branch -a)
CURRENTBRANCH=$(git current-branch)

fail() {
  git checkout $CURRENT
  exit 1
}

if [[ -n $GO ]]; then
  COMMITOPTS=""
else
  COMMITOPTS="-e"
fi

if [[ $# -eq 0 && -n $SVN ]]; then
  #without parameters but with -svn we use svn as upstream branch name
    UP="svn"; DOWN=$CURRENTBRANCH
else
   [[ $# -eq 0 ]] && help
  if [[ $# -eq 1 ]]; then
    if [[ -z "$FROM" ]]; then
      UP="$1"; DOWN=$CURRENTBRANCH
    else #we used -from
      DOWN=$1; UP=$CURRENTBRANCH
    fi
  else
    DOWN="$1"; UP="$2"
  fi
fi

pullmsg=yes; pushmsg=yes
[[ -z $PULL ]] && pullmsg=no
[[ -z $PUSH ]] && pushmsg=no
echo "--- Squashing '$DOWN' on top of '$UP' (pull=$pullmsg/push=$pushmsg) --- (press a key)"
[[ -z $GO ]] && read

#fetching branch
if [[ -n $PULL ]]; then
  echo "1) Pulling '$UP'"
  git checkout $UP || fail
  if [[ -n $SVN ]]; then
    echo "  Using git svn rebase"
    git svn rebase || fail
  else
    git pull || fail
  fi
else
  echo "1) -nopull option, not pulling '$UP'"
fi
# merging the fetch into current branch
git checkout $DOWN || fail

echo "2) Merging '$UP' in '$DOWN'"
MERGEOPTS=
[ -n "$GO" ] && MERGEOPTS=(--no-edit)
git merge $MERGEOPTS $UP || fail

if [[ -n $SKIPSQUASH ]]; then
  echo "Skipping squash"
  exit 0
fi

# squashing the merge
echo "3) Squashing '$DOWN' on top of '$UP'"
git checkout $UP || fail
git merge --ff-only --squash $DOWN ||fail
#mergebase=$(git merge-base $DOWN $UP)
mergebase=$(git rev-parse --verify "$DOWN^{/Trivial merge from '$UP' .squashed by '$DOWN'.}" || git merge-base $DOWN $UP)
echo "Merge base: $mergebase"
echo -e "Squashing '$DOWN' on top of '$UP'\n"  >.git/SQUASH_MSG
git log "^$UP" "$mergebase..$DOWN" >> .git/SQUASH_MSG
git commit $COMMITOPTS -F .git/SQUASH_MSG || fail

# merging the squash
if [[ -n $SVN ]]; then
echo "4) We need to push with svn dcommit first before merging the squash"
else
echo "4) Merging the squash"
git checkout $DOWN ||fail
git merge $COMMITOPTS -m "Trivial merge from '$UP' (squashed by '$DOWN')" $UP ||fail
fi

if [[ -n $PUSH ]]; then
  echo "5) Pushing '$UP'"
  if [[ -n $SVN ]]; then
    echo "  Using git svn dcommit"
    git checkout $UP && git svn dcommit || fail
  else 
    git checkout $UP && git push || fail
  fi
else
  echo "5) -nopush option given, not pushing '$UP'"
fi

if [[ -n $SVN ]]; then
echo "6) Merging the squash"
git checkout $DOWN ||fail
git merge $COMMITOPTS -m "Trivial merge from '$UP' (squashed by '$DOWN')" $UP ||fail
fi

git checkout $CURRENT
