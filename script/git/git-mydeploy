#!/bin/zsh
help() {
  echo "git-mydeploy upstream: deploying script"
  echo "  OPTIONS:
  -l|-local: local git dir (default to current dir) 
  -u|-upstream: upstream git dir (if not specified take \$1)
  -b|-branch: the local branch to push (default to master)
  -rb|-remote-branch: where to push it (default to damien/\$branch)
  -ub|-upstream-branch: the upstream branch to update (default to master)
  -rebase: rebase rather than merge upstreambranch into branch
  -nopull: don't pull only push
  -pullopt opt: do our own pull
  -pushopt opt: do our own push
  -lc|-local-commit [(all)|update|yes|no|none]
  -lo|-local-opt: the local commit options
  -rc|-remote-commit [(all)|update|yes|no|none]
  -ro|-remote-opt: the remote commit options

  COMMIT MODES:
  - all: add all files in the directory (git add -AN && git commit -a)
  - update: git commit -a
  - yes: only commit
  - no: no commit, but still show diff
  - none: do nothing

  git mydeploy update branch, and then push it to remotebranch. It then
  update upstreambranch with remotebranch. This allow to push into a non
  bare repository where upstreambranch should give the deployed data.

  By default, branch is updated with upstreambranch, but by specifying
  -pullopt the user can use it's own pull. The same with pushing (but we
  still assume the push will be in remotebranch)."

exit 0 }

branch=master
remotebranch= #where do I push $branch
upstreambranch=master #which upstream branch I synchronize
remoteupstreambranch= #where do I pull upstream branchin local
LOCAL=$(pwd)
REMOTE=
commitlocal=all
commitremote=all
commitoptlocal=
commitoptremote=
pullaction="script"
pushaction="script"
rebase=

while true;
do
  case "$1" in
   -- ) shift; break ;;
  -l|-local ) shift; LOCAL=$1; shift ;;
  -u|-upstream ) shift; REMOTE=$1; shift ;;
  -b|-branch ) shift; branch=$1; shift ;;
  -rb|-remote-branch ) shift; remotebranch=$1; shift ;;
  -ub|-upstream-branch ) shift; upstreambranch=$1; shift ;;
  -lc|-local-commit ) shift; commitlocal=$1; shift ;;
  -lo|-local-opt ) shift; eval "commitoptlocal=($1)"; shift ;;
  -rc|-remote-commit ) shift; commitremote=$1; shift ;;
  -ro|-remote-opt ) shift; eval "commitoptremote=($1)"; shift ;;
  -rebase ) shift; rebase="yes";;
  -nopull ) shift; pullaction="no";;
  -pullopt ) shift; pullaction="custom"; eval "pullopt=($1)"; shift ;; #the = construction construct an array from each word of the string
  -pushopt ) shift; pushaction="custom"; eval "pushopt=($1)"; shift ;;
  -h|-help|--help ) help ;;
    *) break;;
  esac
done

[ -z "$REMOTE" ] && REMOTE=$1
[ -z "$REMOTE" ] && echo "No upstream specified" && help
[ -z "$remotebranch" ] && remotebranch="damien/$branch"
[ -z "$remoteupstreambranch" ] && remoteupstreambranch="origin/$upstreambranch"

quietdiff() {
  git diff --quiet
  if [ $? -eq 0 ]; then
    echo "Nothing to commit"
    return 1
  else
    git diff 
  fi
}

docommit() {
  MSGOPTIONS=
  msg=
  commit=
  case $1 in
    local ) opt=($commitoptlocal); commit=$commitlocal ;;
    remote ) opt=($commitoptremote); commit=$commitremote ;;
  esac
  echo "(commit options: $opt)"
  #[ -n "$msg" ] && MSGOPTIONS=(-em $msg)
  case $commit in
    #the empty file hash is
    #e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
    all ) git add -AN && quietdiff && git commit $opt -a ;;
    update ) quietdiff && git commit $opt -a ;;
    yes ) quietdiff && git commit $opt ;;
    no ) quietdiff  ;;
    * ) ;;
  esac
}

echo "Synchronizing local $branch on remote $upstreambranch via $remotebranch"

#commiting my repo
echo "### Commiting local $LOCAL"
cd $LOCAL && git checkout $branch && docommit 'local'

#commiting deployed repo
echo "### Commiting remote $REMOTE"
cd $REMOTE && git checkout $upstreambranch && docommit 'remote'

# merging the repos, and if successfull deploying it
# then update the local repo so that it know that the fast forward worked

pullaction() {
  case $pullaction in
    script ) 
      pullopt=
      [ -n "$rebase" ] && pullopt=(--rebase)
      echo "### On local: Pulling $pullopt $REMOTE:$upstreambranch into $LOCAL:$branch"
      git pull $pullopt $REMOTE $upstreambranch ;;
    custom ) 
      echo "### On local: Pulling with options $pullopt" &&
      git pull $pullopt ;;
  esac
}

cd $LOCAL &&
git checkout $branch &&
pullaction

pushaction() {
  case $pushaction in
    script ) 
      echo "### On local: Pushing $LOCAL:$branch to $REMOTE:$remotebranch"
      git push $REMOTE  "$branch:$remotebranch" ;;
    custom ) 
      echo "### On local: Pushing with options $pushopt"
      git push $pushopt ;;
  esac
}

fetchatend() {
  #if pullaction is custom, it is probably because we are tracking
  #upstreambranch. So after updating it, we must pull it again to be sure
  #we are up to date
  case $pullaction in
    custom )
      cd $LOCAL &&
      echo "### On local: Pulling again with options $pullopt to be up to date" &&
      git checkout $branch &&
      git pull --ff-only $pullopt
      ;;
  esac
}

pushaction &&
cd $REMOTE &&
echo "### Updating $REMOTE:$upstreambranch with $remotebranch" &&
git checkout $upstreambranch &&
git merge --ff-only $remotebranch &&
fetchatend
