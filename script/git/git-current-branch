#!/bin/bash
#git current-branch [-al]: give the name of the current branch
# -a always print a name, even if detached
# -l long branch name
#+also some specific commands to get infos on branch names or state of workdir

# From git-parse-remote.sh
#GIT_DIR=$(git rev-parse -q --git-dir) || :;

#are we rebasing by default?
get_rebase () {
  curr_branch=$(git symbolic-ref -q HEAD)
  curr_branch="${curr_branch#refs/heads/}"
  rebase=$(git config --bool branch.$curr_branch.rebase)
  if test -z "$rebase"
  then
      rebase=$(git config --bool pull.rebase)
  fi
  echo $rebase
}

get_default_remote () {
  curr_branch=$(git symbolic-ref -q HEAD)
  curr_branch="${curr_branch#refs/heads/}"
  origin=$(git config --get "branch.$curr_branch.remote")
  echo ${origin:-origin}
}

get_remote_merge_branch () {
  case "$#" in
  0|1)
      origin="$1"
      default=$(get_default_remote)
      test -z "$origin" && origin=$default
      curr_branch=$(git symbolic-ref -q HEAD) &&
      [ "$origin" = "$default" ] &&
      echo $(git for-each-ref --format='%(upstream)' $curr_branch)
      ;;
  *)
      repo=$1
      shift
      ref=$1
      # FIXME: It should return the tracking branch
      #        Currently only works with the default mapping
      case "$ref" in
      +*)
    ref=$(expr "z$ref" : 'z+\(.*\)')
    ;;
      esac
      expr "z$ref" : 'z.*:' >/dev/null || ref="${ref}:"
      remote=$(expr "z$ref" : 'z\([^:]*\):')
      case "$remote" in
      '' | HEAD ) remote=HEAD ;;
      heads/*) remote=${remote#heads/} ;;
      refs/heads/*) remote=${remote#refs/heads/} ;;
      refs/* | tags/* | remotes/* ) remote=
      esac
      [ -n "$remote" ] && case "$repo" in
    .)
        echo "refs/heads/$remote"
        ;;
    *)
        echo "refs/remotes/$repo/$remote"
        ;;
      esac
  esac
}

require_clean_work_tree () {
    # Update the index
    git update-index -q --ignore-submodules --refresh
    err=0

    # Disallow unstaged changes in the working tree
    if ! git diff-files --quiet --ignore-submodules --
    then
        echo >&2 "cannot $1: you have unstaged changes."
        git diff-files --name-status -r --ignore-submodules -- >&2
        err=1
    fi

    # Disallow uncommitted changes in the index
    if ! git diff-index --cached --quiet HEAD --ignore-submodules --
    then
        echo >&2 "cannot $1: your index contains uncommitted changes."
        git diff-index --cached --name-status -r --ignore-submodules HEAD -- >&2
        err=1
    fi

    if [ $err = 1 ]
    then
        echo >&2 "Please commit or stash them."
        exit 1
    fi
}

ALWAYS=
while true;
do
  case "$1" in
    -- ) shift; break ;;
    -a ) shift; ALWAYS="--always" ;; #always print a name
    -l ) shift; LONG=true ;; #long branch name
    -al|-la ) shift; LONG=true; ALWAYS="--always" ;; #always print a name
  --clean ) shift;
    require_clean_work_tree
    exit 0
    ;; #cleaniless state of work tree
  --remote ) shift;
    get_default_remote
    exit 0
    ;; #print the remote of the current branch
  --upstream ) shift;
    get_remote_merge_branch
    exit 0
    ;; #print the upstream of the current branch
    #this is the low level way
    #the high level way is git rev-parse --abbrev-ref --symbolic-full-name @{u}
  --rebase ) shift;
    get_rebase
    exit 0
    ;; #does a pull rebase rather than merge?
  --name-rev ) shift
    git name-rev "$@" | cut -d ' ' -f 2
    exit $?
    ;;
  --contains ) shift
    exec git describe --all --contains $ALWAYS "$@"
    ;;#get the name of a branch
    #more or less equivalent to git name-rev
  --describe ) shift
    exec git describe --all $ALWAYS "$@"
    ;; #describe the branch
  --fullname) shift
    exec git rev-parse --symbolic-full-name "$@"
    ;;
  --symbolic) shift
    exec git rev-parse --symbolic "$@"
    ;;
  --name) shift;
    name=$(git rev-parse --abbrev-ref --symbolic-full-name "$@")
    [[ -n $ALWAYS && -z $name ]] && name=$(git describe --all --always "$@")
    echo $name
    exit $?
    ;;
  --topic ) shift
    . ~/mine/script/git/git-topic-helper
    gth_topic "$@"
    echo "$gth_local,$gth_remote,${gth_rest[@]}"
    exit $?
    ;; #use git-topic-helper
  *) break;;
  esac
done

#to read a symbolic link directly:
#git symbolic-ref [--short] -q HEAD
if [[ -z $LONG ]]; then
  git symbolic-ref --short -q HEAD || {
    if [[ -n $ALWAYS ]]; then git rev-parse --verify HEAD; fi
  }
else
  #git rev-parse --symbolic-full-name HEAD || {
  git symbolic-ref -q HEAD || {
    if [[ -n $ALWAYS ]]; then git rev-parse --verify HEAD; fi
  }
fi
