# vim: ft=markdown foldmethod=marker:

# Reset  {{{1

## Undo commit and redo (reset --soft, commit --ammend)
      $ git commit ...
      $ git reset --soft HEAD^      (1)
      $ edit                        (2)
      $ git commit -a -c ORIG_HEAD  (3)
  1. This is most often done when you remembered what you just
  committed is incomplete, or you misspelled your commit message, or
  both. Leaves working tree as it was before "reset".
  2. Make corrections to working tree files.
  3. "reset" copies the old head to `.git/ORIG_HEAD;` redo the commit
  by starting with its log message. If you do not need to edit the
  message further, you can give -C option instead.
-> shortcut: git commit --amend

## Undo a commit, making it a topic branch (reset --hard)
      $ git branch topic/wip     (1)
      $ git reset --hard HEAD~3  (2)
      $ git checkout topic/wip   (3)
  1. You have made some commits, but realize they were premature to
  be in the "master" branch. You want to continue polishing them in a
  topic branch, so create "topic/wip" branch off of the current HEAD.
  2. Rewind the master branch to get rid of those three commits.
  3. Switch to "topic/wip" branch and keep working.

## Undo a merge or pull (reset --hard)
      $ git pull                         (1)
      Auto-merging nitfol
      CONFLICT (content): Merge conflict in nitfol
      Automatic merge failed; fix conflicts and then commit the result.
      $ git reset --hard                 (2)
      $ git pull . topic/branch          (3)
      Updating from 41223... to 13134...
      Fast-forward
      $ git reset --hard ORIG_HEAD       (4)
  1. Try to update from the upstream resulted in a lot of conflicts;
  you were not ready to spend a lot of time merging right now, so you
  decide to do that later.
  2. "pull" has not made merge commit, so "git reset --hard" which is
  a synonym for "git reset --hard HEAD" clears the mess from the
  index file and the working tree.
  3. Merge a topic branch into the current branch, which resulted in
  a fast-forward.
  4. But you decided that the topic branch is not ready for public
  consumption yet. "pull" or "merge" always leaves the original tip
  of the current branch in `ORIG_HEAD`, so resetting hard to it brings
  your index file and the working tree back to that state, and resets
  the tip of the branch to that commit.

## Undo a merge or pull inside a dirty working tree (reset --merge)
      $ git pull                         (1)
      Auto-merging nitfol
      Merge made by recursive.
       nitfol                |   20 +++++----
      $ git reset --merge ORIG_HEAD      (2)
  1. Even if you may have local modifications in your working tree,
  you can safely say "git pull" when you know that the change in the
  other branch does not overlap with them.
  2. After inspecting the result of the merge, you may find that the
  change in the other branch is unsatisfactory. Running `"git reset
  --hard ORIG_HEAD"` will let you go back to where you were, but it
  will discard your local changes, which you do not want. "git reset
  --merge" keeps your local changes.

## Interrupted workflow (reset, stash)
  Suppose you are interrupted by an urgent fix request while you are
  in the middle of a large change. The files in your working tree are
  not in any shape to be committed yet, but you need to get to the
  other branch for a quick bugfix.
      $ git checkout feature ;# you were working in "feature" branch and
      $ work work work       ;# got interrupted
      $ git commit -a -m "snapshot WIP"                 (1)
      $ git checkout master
      $ fix fix fix
      $ git commit ;# commit with real log
      $ git checkout feature
      $ git reset --soft HEAD^ ;# go back to WIP state  (2)
      $ git reset                                       (3)
  1. This commit will get blown away so a throw-away log message is OK.
  2. This removes the WIP commit from the commit history, and sets
  your working tree to the state just before you made that snapshot.
  3. At this point the index file still has all the WIP changes you
  committed as snapshot WIP. This updates the index to show your WIP
  files as uncommitted.
  See also git-stash(1).

## Reset a single file in the index (reset)
  Suppose you have added a file to your index, but later decide you
  do not want to add it to your commit. You can remove the file from
  the index while keeping your changes with git reset.
      $ git reset -- frotz.c                      (1)
      $ git commit -m "Commit files in index"     (2)
      $ git add frotz.c                           (3)
  1. This removes the file from the index while keeping it in the
  working directory.
  2. This commits all other changes in the index.
  3. Adds the file to the index again.

## Keep changes in working tree while discarding some previous commits (reset --keep)
  Suppose you are working on something and you commit it, and then
  you continue working a bit more, but now you think that what you
  have in your working tree should be in another branch that has
  nothing to do with what you committed previously. You can start a
  new branch and reset it while keeping the changes in your working
  tree.
      $ git tag start
      $ git checkout -b branch1
      $ edit
      $ git commit ...                            (1)
      $ edit
      $ git checkout -b branch2                   (2)
      $ git reset --keep start                    (3)
  1. This commits your first edits in branch1.
  2. In the ideal world, you could have realized that the earlier
  commit did not belong to the new topic when you created and
  switched to branch2 (i.e. "git checkout -b branch2 start"), but
  nobody is perfect.
  3. But you can use "reset --keep" to remove the unwanted commit
  after you switched to "branch2".

# Stash {{{1

## Pulling into a dirty tree
  When you are in the middle of something, you learn that there are
  upstream changes that are possibly relevant to what you are doing.
  When your local changes do not conflict with the changes in the
  upstream, a simple git pull will let you move forward.

  However, there are cases in which your local changes do conflict
  with the upstream changes, and git pull refuses to overwrite your
  changes. In such a case, you can stash your changes away, perform a
  pull, and then unstash, like this:

      $ git pull
       ...
      file foobar not up to date, cannot merge.
      $ git stash
      $ git pull
      $ git stash pop

## Interrupted workflow
  When you are in the middle of something, your boss comes in and
  demands that you fix something immediately. Traditionally, you
  would make a commit to a temporary branch to store your changes
  away, and return to your original branch to make the emergency fix,
  like this:
      # ... hack hack hack ...
      $ git checkout -b my_wip
      $ git commit -a -m "WIP"
      $ git checkout master
      $ edit emergency fix
      $ git commit -a -m "Fix in a hurry"
      $ git checkout my_wip
      $ git reset --soft HEAD^
      # ... continue hacking ...
  You can use git stash to simplify the above, like this:
      # ... hack hack hack ...
      $ git stash
      $ edit emergency fix
      $ git commit -a -m "Fix in a hurry"
      $ git stash pop
      # ... continue hacking ...

## Testing partial commits
  You can use git stash save --keep-index when you want to make two
  or more commits out of the changes in the work tree, and you want
  to test each change before committing:

      # ... hack hack hack ...
      $ git add --patch foo            # add just first part to the index
      $ git stash save --keep-index    # save all other changes to the stash
      $ edit/build/test first part
      $ git commit -m 'First part'     # commit fully tested change
      $ git stash pop                  # prepare to work on all other changes
      # ... repeat above five steps until one commit remains ...
      $ edit/build/test remaining parts
      $ git commit foo -m 'Remaining parts'

## Recovering stashes that were cleared/dropped erroneously
  If you mistakenly drop or clear stashes, they cannot be recovered
  through the normal safety mechanisms. However, you can try the
  following incantation to get a list of stashes that are still in
  your repository, but not reachable any more:

      git fsck --unreachable |
      grep commit | cut -d\  -f3 |
      xargs git log --merges --no-walk --grep=WIP

# git diff {{{1
git show A..B montre tous les commits parents de B qui ne sont pas parents
de A.

git show A...B montre tous les commits parents de A ou de B qui ne sont pas
parents des 2 (différence symétrique).

git diff A..B est pareil que git diff A B: ça montre la différence entre A
et B

Le plus fort: git diff A...B montre les différences entre (l'ancêtre commun
de A et B) et B (ie c'est équivalent à git diff $(git-merge-base A B) B)!

# Basic file operations {{{1
git status

 On branch master
 Changes to be committed:
   (use "git reset HEAD <file>..." to unstage)

       renamed:    git-addremove -> ex/git-addremove

 Changes not staged for commit:
   (use "git add <file>..." to update what will be committed)
   (use "git checkout -- <file>..." to discard changes in working
irectory)

       modified:   ../logiciels/usbautosuspend

 Untracked files:
   (use "git add <file>..." to include in what will be committed)

       ../ruby/

