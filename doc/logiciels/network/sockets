**EXTRAITS** de pages de man concernant le rézo

-------------------------------------------------------------------------------
NAME
       capabilities - overview of Linux capabilities

DESCRIPTION
       For  the  purpose  of  performing  permission  checks, traditional Unix
       implementations distinguish two  categories  of  processes:  privileged
       processes  (whose  effective  user ID is 0, referred to as superuser or
       root), and unprivileged processes (whose effective  UID  is  non-zero).
       Privileged processes bypass all kernel permission checks, while unpriv‐
       ileged processes are subject to full permission checking based  on  the
       process’s  credentials (usually: effective UID, effective GID, and sup‐
       plementary group list).

       Starting with kernel 2.2, Linux provides an (as yet incomplete)  system
       of  capabilities,  which divide the privileges traditionally associated
       with superuser into distinct units that can  be  independently  enabled
       and disabled.

-------------------------------------------------------------------------------
NAME
       fcntl - manipulate file descriptor

SYNOPSIS
       #include <unistd.h>
       #include <fcntl.h>

       int fcntl(int fd, int cmd);
       int fcntl(int fd, int cmd, long arg);
       int fcntl(int fd, int cmd, struct flock *lock);

DESCRIPTION
       fcntl  performs  one  of  various  miscellaneous operations on fd.  The
       operation in question is determined by cmd.
------------------------------------------------------------------------------
NAME
       sysctl - configure kernel parameters at runtime

SYNOPSIS
       sysctl [-n] [-e] variable ...
       sysctl [-n] [-e] [-q] -w variable=value ...
       sysctl [-n] [-e] [-q] -p <filename>
       sysctl [-n] [-e] -a
       sysctl [-n] [-e] -A

DESCRIPTION
       sysctl  is used to modify kernel parameters at runtime.  The parameters
       available are those listed under /proc/sys/.  Procfs  is  required  for
       sysctl(8)  support  in  Linux.   You can use sysctl(8) to both read and
       write sysctl data.
------------------------------------------------------------------------------
NAME
       ioctl - control device

SYNOPSIS
       #include <sys/ioctl.h>

       int ioctl(int d, int request, ...);

DESCRIPTION
       The ioctl function manipulates the underlying device parameters of spe‐
       cial files.  In particular, many operating characteristics of character
       special  files  (e.g. terminals) may be controlled with ioctl requests.
       The argument d must be an open file descriptor.

-------------------------------------------------------------------------------

*******************************************************************************

-------------------------------------------------------------------------------

NAME
       socket - create an endpoint for communication

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       int socket(int domain, int type, int protocol);

Socket  creates an endpoint for communication and returns a descriptor.

SOCKET LAYER FUNCTIONS
       These functions are used by the user process to send or receive packets
       and  to  do  other  socket  operations.  For more information see their
       respective manual pages.

       socket(2) creates a socket, connect(2) connects a socket  to  a  remote
       socket  address,  the bind(2) function binds a socket to a local socket
       address, listen(2) tells the  socket  that  new  connections  shall  be
       accepted, and accept(2) is used to get a new socket with a new incoming
       connection.  socketpair(2)  returns  two  connected  anonymous  sockets
       (only implemented for a few local families like PF_UNIX)

       send(2),  sendto(2),  and  sendmsg(2)  send  data  over  a  socket, and
       recv(2), recvfrom(2), recvmsg(2) receive data from a  socket.   poll(2)
       and  select(2)  wait for arriving data or a readiness to send data.  In
       addition, the standard I/O operations like write(2),  writev(2),  send‐
       file(2), read(2), and readv(2) can be used to read and write data.

       getsockname(2)  returns  the  local  socket  address and getpeername(2)
       returns the remote socket address.  getsockopt(2) and setsockopt(2) are
       used  to  set or get socket layer or protocol options.  ioctl(2) can be
       used to set or read some other options.

       close(2) is used to close a socket.  shutdown(2) closes parts of a full
       duplex socket connection.

       Seeking,  or  calling pread(2) or pwrite(2) with a non-zero position is
       not supported on sockets.

       It is possible to do non-blocking IO on sockets by setting  the  O_NON‐
       BLOCK flag on a socket file descriptor using fcntl(2).  Then all opera‐
       tions that would block will (usually)  return  with  EAGAIN  (operation
       should  be  retried  later);  connect(2) will return EINPROGRESS error.
       The user can then wait for various events via poll(2) or select(2).

Ce sont des FDs, on peut leur appliquer des fcntl.
Réglages spécifiques: setsockopt, getsockopt.

Domain: PF_UNIX, PF_INET, PF_INET6, PF_PACKET...
Type: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW...
Protocol: 0 la plupart du temps

Si SOCK_STREAM:
connect, read+write / send+recv, close
options: SO_KEEPALIVE
fin connexion -> SIGPIPE

SOCK_DGRAM:
send+recvfrom

SEE ALSO
       accept(2),  bind(2),  connect(2),  fcntl(2),  getpeername(2),  getsock‐
       name(2),   getsockopt(2),   ioctl(2),   listen(2),   read(2),  recv(2),
       select(2),  send(2),  shutdown(2),  socketpair(2),  write(2),   getpro‐
       toent(3), ip(7), socket(7), tcp(7), udp(7), unix(7)

       Stevens: Unix Network Programming, 2nd Edition, Volume 1
       man perlipc
-------------------------------------------------------------------------------
NAME
       getsockopt, setsockopt - get and set options on sockets

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       int  getsockopt(int  s, int level, int optname, void *optval, socklen_t
       *optlen);

       int setsockopt(int s, int  level,  int  optname,  const  void  *optval,
       socklen_t optlen);

DESCRIPTION
       Getsockopt  and  setsockopt  manipulate  the  options associated with a
       socket.  Options may exist at multiple protocol levels; they are always
       present at the uppermost socket level.

       When  manipulating socket options the level at which the option resides
       and the name of the option must be specified.  To manipulate options at
       the  socket  level,  level  is  specified as SOL_SOCKET.  To manipulate
       options at any other level the protocol number of the appropriate  pro‐
       tocol  controlling  the  option  is supplied.  For example, to indicate
       that an option is to be interpreted by the TCP protocol,  level  should
       be set to the protocol number of TCP; see getprotoent(3).

       The  parameters  optval and optlen are used to access option values for
       setsockopt.  For getsockopt they identify a buffer in which  the  value
       for the requested option(s) are to be returned.  For getsockopt, optlen
       is a value-result parameter,  initially  containing  the  size  of  the
       buffer  pointed  to  by  optval, and modified on return to indicate the
       actual size of the value returned.  If no option value is  to  be  sup‐
       plied or returned, optval may be NULL.

       Optname  and  any  specified  options  are  passed uninterpreted to the
       appropriate protocol  module  for  interpretation.   The  include  file
       <sys/socket.h> contains definitions for socket level options, described
       below.  Options at other protocol levels vary in format and name;  con‐
       sult the appropriate entries in section 4 of the manual.

       Most  socket-level  options  utilize  an int parameter for optval.  For
       setsockopt, the parameter  should  be  non-zero  to  enable  a  boolean
       option, or zero if the option is to be disabled.

       For a description of the available socket options see socket(7) and the
       appropriate protocol man pages.
-------------------------------------------------------------------------------

NAME
       unix,  PF_UNIX,  AF_UNIX, PF_LOCAL, AF_LOCAL - Sockets for local inter‐
       process communication

SYNOPSIS
       #include <sys/socket.h>
       #include <sys/un.h>

       unix_socket = socket(PF_UNIX, type, 0);
       error = socketpair(PF_UNIX, type, 0, int *sv);

DESCRIPTION
       The PF_UNIX (also known as PF_LOCAL) socket family is used to  communi‐
       cate  between  processes  on the same machine efficiently. Unix sockets
       can be either anonymous (created by socketpair(2)) or associated with a
       file  of  type socket.  Linux also supports an abstract namespace which
       is independent of the file system.

       Valid  types  are:  SOCK_STREAM,  for  a  stream-oriented  socket   and
       SOCK_DGRAM,  for  a  datagram-oriented  socket  that  preserves message
       boundaries (as on most Unix implementations, Unix domain datagram sock‐
       ets are always reliable and don’t reorder datagrams); and (since kernel
       2.6.4) SOCK_SEQPACKET, for a connection-oriented socket that  preserves
       message  boundaries  and  delivers messages in the order that they were
       sent.

       Unix sockets support passing file descriptors or process credentials to
       other processes using ancillary data.

ADDRESS FORMAT
       A  Unix  address  is  defined  as  a filename in the filesystem or as a
       unique string in the abstract namespace.  Sockets  created  by  socket‐
       pair(2) are anonymous. For non-anonymous sockets the target address can
       be set using connect(2).  The local address can be set  using  bind(2).
       When  a socket is connected and it doesn’t already have a local address
       a unique address in the abstract namespace will be generated  automati‐
       cally.

              #define UNIX_PATH_MAX    108

              struct sockaddr_un {
                  sa_family_t  sun_family;              /* AF_UNIX */
                  char         sun_path[UNIX_PATH_MAX]; /* pathname */
              };

       sun_family  always contains AF_UNIX.  sun_path contains the zero-termi‐
       nated pathname of the socket in the file system.   If  sun_path  starts
       with  a zero byte it refers to the abstract namespace maintained by the
       Unix protocol module.  The socket’s address in this namespace is  given
       by  the rest of the bytes in sun_path.  Note that names in the abstract
       namespace are not zero-terminated.

ANCILLARY MESSAGES
       Ancillary data is sent and received using  sendmsg(2)  and  recvmsg(2).
       For  historical  reasons  the  ancillary message types listed below are
       specified with a SOL_SOCKET type even though they are PF_UNIX specific.
       To  send  them  set  the  cmsg_level  field  of  the  struct cmsghdr to
       SOL_SOCKET and the cmsg_type field to the type.  For  more  information
       see cmsg(3).

NOTES
       In the Linux implementation, sockets which are visible in the  filesys‐
       tem  honour  the permissions of the directory they are in. Their owner,
       group and their permissions can be changed.  Creation of a  new  socket
       will  fail if the process does not have write and search (execute) per‐
       mission on the directory the socket is created in.  Connecting  to  the
       socket  object  requires  read/write permission.  This behavior differs
       from many BSD-derived systems which ignore permissions for  Unix  sock‐
       ets. Portable programs should not rely on this feature for security.

       Binding to a socket with a filename creates a socket in the file system
       that must be deleted by the caller when it is no longer  needed  (using
       unlink(2)).   The  usual  Unix close-behind semantics apply; the socket
       can be unlinked at any time and will be finally removed from  the  file
       system when the last reference to it is closed.

       To pass file descriptors or credentials over a SOCK_STREAM, you need to
       send/recv  at  least  one  byte  of  non-ancillary  data  in  the  same
       send/recv_msg call.
-----------------------------------------------------------------------------

NAME
       ip - Linux IPv4 protocol implementation

SYNOPSIS
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <netinet/ip.h> /* superset of previous */

       tcp_socket = socket(PF_INET, SOCK_STREAM, 0);
       raw_socket = socket(PF_INET, SOCK_RAW, protocol);
       udp_socket = socket(PF_INET, SOCK_DGRAM, protocol);

DESCRIPTION
       Linux  implements the Internet Protocol, version 4, described in RFC791
       and RFC1122.  ip contains a level 2  multicasting  implementation  con‐
       forming  to  RFC1112.  It also contains an IP router including a packet
       filter.

       The programmer’s interface is BSD sockets compatible.  For more  infor‐
       mation on sockets, see socket(7).

       An   IP  socket  is  created  by  calling  the  socket(2)  function  as
       socket(PF_INET,  socket_type,  protocol).   Valid  socket   types   are
       SOCK_STREAM  to  open  a  tcp(7)  socket,  SOCK_DGRAM  to open a udp(7)
       socket, or SOCK_RAW to open a raw(7) socket to access the  IP  protocol
       directly.   protocol is the IP protocol in the IP header to be received
       or sent.  The only valid values for protocol are 0 and IPPROTO_TCP  for
       TCP  sockets  and  0 and IPPROTO_UDP for UDP sockets.  For SOCK_RAW you
       may specify a valid IANA IP protocol defined in RFC1700  assigned  num‐
       bers.

       When a process wants to receive new incoming packets or connections, it
       should bind a socket to a local interface address using bind(2).   Only
       one  IP  socket  may  be bound to any given local (address, port) pair.
       When INADDR_ANY is specified in the bind call the socket will be  bound
       to  all local interfaces. When listen(2) or connect(2) are called on an
       unbound socket it is automatically bound to a random free port with the
       local address set to INADDR_ANY.

       A  TCP local socket address that has been bound is unavailable for some
       time after closing, unless the SO_REUSEADDR flag has  been  set.   Care
       should be taken when using this flag as it makes TCP less reliable.

ADDRESS FORMAT
       An  IP  socket  address  is defined as a combination of an IP interface
       address and a port number. The basic IP protocol does not  supply  port
       numbers, they are implemented by higher level protocols like udp(7) and
       tcp(7).  On raw sockets sin_port is set to the IP protocol.

              struct sockaddr_in {
                  sa_family_t    sin_family; /* address family: AF_INET */
                  u_int16_t      sin_port;   /* port in network byte order */
                  struct in_addr  sin_addr;  /* internet address */
              };

              /* Internet address. */
              struct in_addr {
                  u_int32_t      s_addr;     /* address in network byte order */
              };

       sin_family is always set to AF_INET.  This is required;  in  Linux  2.2
       most  networking  functions return EINVAL when this setting is missing.
       sin_port contains the port in network  byte  order.  The  port  numbers
       below  1024  are  called reserved ports.  Only processes with effective
       user id 0 or the CAP_NET_BIND_SERVICE capability may bind(2)  to  these
       sockets.  Note  that  the raw IPv4 protocol as such has no concept of a
       port, they are only implemented by higher  protocols  like  tcp(7)  and
       udp(7).

       sin_addr  is  the  IP  host address.  The addr member of struct in_addr
       contains the host interface address in network order.   in_addr  should
       be only accessed using the inet_aton(3), inet_addr(3), inet_makeaddr(3)
       library functions or directly with the name  resolver  (see  gethostby‐
       name(3)).   IPv4 addresses are divided into unicast, broadcast and mul‐
       ticast addresses. Unicast addresses specify a  single  interface  of  a
       host,  broadcast addresses specify all hosts on a network and multicast
       addresses address all hosts in a multicast group. Datagrams  to  broad‐
       cast  addresses  can  be  only  sent  or received when the SO_BROADCAST
       socket flag is set.  In the current implementation connection  oriented
       sockets are only allowed to use unicast addresses.

       Note  that the address and the port are always stored in network order.
       In particular, this means that you need to call htons(3) on the  number
       that  is assigned to a port. All address/port manipulation functions in
       the standard library work in network order.

       There are several special addresses: INADDR_LOOPBACK (127.0.0.1) always
       refers  to the local host via the loopback device; INADDR_ANY (0.0.0.0)
       means any address for binding; INADDR_BROADCAST (255.255.255.255) means
       any  host  and has the same effect on bind as INADDR_ANY for historical
       reasons.
-------------------------------------------------------------------------------
NAME
       udp - User Datagram Protocol for IPv4

SYNOPSIS
       #include <sys/socket.h>
       #include <netinet/in.h>
       udp_socket = socket(PF_INET, SOCK_DGRAM, 0);

DESCRIPTION
       When a UDP socket is  created,  its  local  and  remote  addresses  are
       unspecified.   Datagrams  can  be  sent  immediately using sendto(2) or
       sendmsg(2) with a valid destination address as an argument.  When  con‐
       nect(2)  is called on the socket the default destination address is set
       and datagrams can now be sent using send(2) or write(2) without  speci‐
       fying  an  destination  address.  It is still possible to send to other
       destinations by passing an address  to  sendto(2)  or  sendmsg(2).   In
       order  to  receive  packets the socket can be bound to an local address
       first by using bind(2).  Otherwise the socket layer will  automatically
       assign   a   free   local   port   out   of   the   range   defined  by
       net.ipv4.ip_local_port_range and bind the socket to INADDR_ANY.

       All receive operations return only one  packet.   When  the  packet  is
       smaller than the passed buffer only that much data is returned, when it
       is bigger the packet is  truncated  and  the  MSG_TRUNC  flag  is  set.
       MSG_WAITALL is not supported.

-------------------------------------------------------------------------------
NAME
       tcp - TCP protocol

SYNOPSIS
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <netinet/tcp.h>
       tcp_socket = socket(PF_INET, SOCK_STREAM, 0);

DESCRIPTION
       A  fresh  TCP  socket  has  no remote or local address and is not fully
       specified.  To create an outgoing  TCP  connection  use  connect(2)  to
       establish  a connection to another TCP socket.  To receive new incoming
       connections bind(2) the socket first to a local address  and  port  and
       then call listen(2) to put the socket into listening state.  After that
       a new socket  for  each  incoming  connection  can  be  accepted  using
       accept(2).   A  socket  which  has  had  accept or connect successfully
       called on it is fully specified and may transmit data.  Data cannot  be
       transmitted on listening or not yet connected sockets.

NOTES
       When an error occurs doing a connection setup  occurring  in  a  socket
       write  SIGPIPE  is  only  raised when the SO_KEEPALIVE socket option is
       set.
-------------------------------------------------------------------------------

*******************************************************************************
-------------------------------------------------------------------------------
NAME
       connect - initiate a connection on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       int  connect(int  sockfd,  const  struct sockaddr *serv_addr, socklen_t
       addrlen);

DESCRIPTION
       The file descriptor sockfd must refer to a socket.  If the socket is of
       type  SOCK_DGRAM  then  the  serv_addr  address is the address to which
       datagrams are sent by default, and the only address  from  which  data‐
       grams  are received.  If the socket is of type SOCK_STREAM or SOCK_SEQ‐
       PACKET, this call attempts to make a connection to another socket.  The
       other  socket is specified by serv_addr, which is an address (of length
       addrlen) in the communications space of the  socket.   Each  communica‐
       tions space interprets the serv_addr parameter in its own way.

       Generally,  connection-based  protocol sockets may successfully connect
       only once; connectionless protocol sockets  may  use  connect  multiple
       times to change their association.  Connectionless sockets may dissolve
       the association by connecting to an address with the  sa_family  member
       of sockaddr set to AF_UNSPEC.

RETURN VALUE
       If  the connection or binding succeeds, zero is returned.  On error, -1
       is returned, and errno is set appropriately.

-------------------------------------------------------------------------------
NAME
       bind - bind a name to a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       int   bind(int   sockfd,  const  struct  sockaddr  *my_addr,  socklen_t
       addrlen);

DESCRIPTION
       bind gives the socket sockfd the local  address  my_addr.   my_addr  is
       addrlen bytes long.  Traditionally, this is called “assigning a name to
       a socket.”  When a socket is created with socket(2),  it  exists  in  a
       name space (address family) but has no name assigned.

       It  is normally necessary to assign a local address using bind before a
       SOCK_STREAM socket may receive connections (see accept(2)).

       The rules used in name binding vary between address families.   Consult
       the  manual entries in Section 7 for detailed information.  For AF_INET
       see ip(7), for AF_UNIX see unix(7), for AF_APPLETALK  see  ddp(7),  for
       AF_PACKET  see  packet(7), for AF_X25 see x25(7) and for AF_NETLINK see
       netlink(7).

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and  errno  is
       set appropriately.
-------------------------------------------------------------------------------
NAME
       getsockname - get socket name

SYNOPSIS
       #include <sys/socket.h>

       int getsockname(int s, struct sockaddr *name, socklen_t *namelen);

DESCRIPTION
       Getsockname  returns  the  current  name for the specified socket.  The
       namelen parameter should be initialized to indicate the amount of space
       pointed  to by name.  On return it contains the actual size of the name
       returned (in bytes).
-------------------------------------------------------------------------------
NAME
       socketpair - create a pair of connected sockets

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       int socketpair(int d, int type, int protocol, int sv[2]);

DESCRIPTION
       The socketpair call creates an unnamed pair of connected sockets in the
       specified domain d, of the specified type,  and  using  the  optionally
       specified  protocol.  The descriptors used in referencing the new sock‐
       ets are returned in sv[0] and sv[1].  The  two  sockets  are  indistin‐
       guishable.
--------------------------------------------------------------------------------
NAME
       pipe - create pipe

SYNOPSIS
       #include <unistd.h>

       int pipe(int filedes[2]);

DESCRIPTION
       pipe  creates a pair of file descriptors, pointing to a pipe inode, and
       places them in the array pointed to  by  filedes.   filedes[0]  is  for
       reading, filedes[1] is for writing.

------------------------------------------------------------------------------
NAME
       listen - listen for connections on a socket

SYNOPSIS
       #include <sys/socket.h>

       int listen(int s, int backlog);

DESCRIPTION
       To  accept  connections,  a  socket  is first created with socket(2), a
       willingness to accept incoming connections and a queue limit for incom‐
       ing connections are specified with listen, and then the connections are
       accepted with accept(2).  The listen call applies only  to  sockets  of
       type SOCK_STREAM or SOCK_SEQPACKET.

       The  backlog  parameter defines the maximum length the queue of pending
       connections may grow to.  If a  connection  request  arrives  with  the
       queue  full the client may receive an error with an indication of ECON‐
       NREFUSED or, if the underlying protocol  supports  retransmission,  the
       request may be ignored so that retries succeed.
-------------------------------------------------------------------------------
NAME
       accept - accept a connection on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       int accept(int s, struct sockaddr *addr, socklen_t *addrlen);

DESCRIPTION
       The   accept  function  is  used  with  connection-based  socket  types
       (SOCK_STREAM, SOCK_SEQPACKET and SOCK_RDM).  It extracts the first con‐
       nection request on the queue of pending connections, creates a new con‐
       nected socket with mostly the same properties as s, and allocates a new
       file  descriptor  for the socket, which is returned.  The newly created
       socket is no longer in the listening state.  The original socket  s  is
       unaffected  by  this  call.  Note  that  any  per file descriptor flags
       (everything that can be set with the F_SETFL fcntl, like  non  blocking
       or async state) are not inherited across an accept.

       The  argument s is a socket that has been created with socket(2), bound
       to a local address with bind(2), and is listening for connections after
       a listen(2).

       The  argument addr is a pointer to a sockaddr structure. This structure
       is filled in with the address of the connecting entity, as known to the
       communications  layer.   The  exact format of the address passed in the
       addr parameter is determined by the socket’s family (see socket(2)  and
       the  respective  protocol man pages).  The addrlen argument is a value-
       result parameter: it should initially contain the size of the structure
       pointed  to  by  addr;  on return it will contain the actual length (in
       bytes) of the address returned. When addr is NULL nothing is filled in.

       If  no  pending connections are present on the queue, and the socket is
       not marked as non-blocking, accept blocks the caller until a connection
       is  present.   If the socket is marked non-blocking and no pending con‐
       nections are present on the queue, accept returns EAGAIN.

       In order to be notified of incoming connections on a  socket,  you  can
       use  select(2)  or  poll(2).  A readable event will be delivered when a
       new connection is attempted and you may  then  call  accept  to  get  a
       socket  for  that connection.  Alternatively, you can set the socket to
       deliver SIGIO when activity occurs  on  a  socket;  see  socket(7)  for
       details.

       For  certain  protocols which require an explicit confirmation, such as
       DECNet, accept can be thought of as merely dequeuing the  next  connec‐
       tion  request  and  not  implying  confirmation.   Confirmation  can be
       implied by a normal read or write  on  the  new  file  descriptor,  and
       rejection can be implied by closing the new socket. Currently only DEC‐
       Net has these semantics on Linux.

NOTES
       There may not always be a connection waiting after a SIGIO is delivered
       or  select(2) or poll(2) return a readability event because the connec‐
       tion might have been  removed  by  an  asynchronous  network  error  or
       another  thread before accept is called.  If this happens then the call
       will block waiting for the next connection to arrive.  To  ensure  that
       accept  never  blocks, the passed socket s needs to have the O_NONBLOCK
       flag set (see socket(7)).

-------------------------------------------------------------------------------

******************************************************************************

-------------------------------------------------------------------------------
NAME
       inet_aton,    inet_addr,    inet_network,   inet_ntoa,   inet_makeaddr,
       inet_lnaof, inet_netof - Internet address manipulation routines

SYNOPSIS
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <arpa/inet.h>

       int inet_aton(const char *cp, struct in_addr *inp);

       in_addr_t inet_addr(const char *cp);

       in_addr_t inet_network(const char *cp);

       char *inet_ntoa(struct in_addr in);

       struct in_addr inet_makeaddr(int net, int host);

       in_addr_t inet_lnaof(struct in_addr in);

       in_addr_t inet_netof(struct in_addr in);

DESCRIPTION
       inet_aton() converts the Internet host address  cp  from  the  standard
       numbers-and-dots  notation into binary data and stores it in the struc‐
       ture that inp points to. inet_aton returns nonzero if  the  address  is
       valid, zero if not.

       The  inet_addr()  function  converts  the Internet host address cp from
       numbers-and-dots notation into binary data in network byte  order.   If
       the input is invalid, INADDR_NONE (usually -1) is returned.  This is an
       obsolete interface to inet_aton, described  immediately  above;  it  is
       obsolete because -1 is a valid address (255.255.255.255), and inet_aton
       provides a cleaner way to indicate error return.

       The inet_network() function extracts the network number  in  host  byte
       order  from  the address cp in numbers-and-dots notation.  If the input
       is invalid, -1 is returned.

       The inet_ntoa() function converts the Internet host address in given in
       network  byte  order to a string in standard numbers-and-dots notation.
       The string is returned in a statically allocated buffer,  which  subse‐
       quent calls will overwrite.

       The  inet_makeaddr() function makes an Internet host address in network
       byte order by combining the network number net with the  local  address
       host in network net, both in local host byte order.

       The  inet_lnaof()  function  returns the local host address part of the
       Internet address in.  The local host address is returned in local  host
       byte order.

       The inet_netof() function returns the network number part of the Inter‐
       net Address in.  The network number is  returned  in  local  host  byte
       order.

       The   structure   in_addr  as  used  in  inet_ntoa(),  inet_makeaddr(),
       inet_lnoaf() and inet_netof() is defined in netinet/in.h as:

              struct in_addr {
                      unsigned long int s_addr;
              }

       Note that on the i80x86 the host byte order is Least  Significant  Byte
       first, whereas the network byte order, as used on the Internet, is Most
       Significant Byte first.
-------------------------------------------------------------------------------
NAME
       gethostbyname,  gethostbyaddr, sethostent, gethostend, endhostent, her‐
       ror, hstrerror - get network host entry

SYNOPSIS
       #include <netdb.h>
       extern int h_errno;

       struct hostent *gethostbyname(const char *name);

       #include <sys/socket.h>       /* for AF_INET */
       struct hostent *
       gethostbyaddr(const void *addr, int len, int type);

       void sethostent(int stayopen);

       void endhostent(void);

       void herror(const char *s);

       const char *hstrerror(int err);

       /* SYSV/POSIX extension */
       struct hostent *gethostent(void);

       /* GNU extensions */
       struct hostent *gethostbyname2(const char *name, int af);

       int gethostent_r(
         struct hostent *ret, char *buf, size_t buflen,
         struct hostent **result, int *h_errnop);

       int gethostbyname_r(const char *name,
         struct hostent *ret, char *buf, size_t buflen,
         struct hostent **result, int *h_errnop);

       int gethostbyname2_r(const char *name, int af,
         struct hostent *ret, char *buf, size_t buflen,
         struct hostent **result, int *h_errnop);

DESCRIPTION
       The gethostbyname() function returns a structure of  type  hostent  for
       the  given  host  name.   Here  name  is either a host name, or an IPv4
       address in standard dot notation, or an IPv6 address in colon (and pos‐
       sibly  dot)  notation.   (See  RFC  1884  for  the  description of IPv6
       addresses.)  If name is an IPv4 or IPv6 address, no lookup is performed
       and  gethostbyname()  simply  copies name into the h_name field and its
       struct in_addr equivalent into the h_addr_list[0] field of the returned
       hostent  structure.   If  name doesn’t end in a dot and the environment
       variable HOSTALIASES is set, the alias file pointed to  by  HOSTALIASES
       will  first be searched for name (see hostname(7) for the file format).
       The current domain and its parents are searched unless name ends  in  a
       dot.

       The  gethostbyaddr()  function  returns a structure of type hostent for
       the given host address addr of length len and address type type.  Valid
       address types are AF_INET and AF_INET6.  The host address argument is a
       pointer to a struct of a type depending on the address type, for  exam‐
       ple  a  struct  in_addr * (probably obtained via a call to inet_addr())
       for address type AF_INET.

       The sethostent() function specifies, if stayopen is true  (1),  that  a
       connected  TCP  socket  should  be used for the name server queries and
       that the connection should remain open during successive queries.  Oth‐
       erwise, name server queries will use UDP datagrams.

       The  endhostent()  function  ends  the use of a TCP connection for name
       server queries.

       The (obsolete) herror() function prints the  error  message  associated
       with the current value of h_errno on stderr.

       The  (obsolete)  hstrerror()  function takes an error number (typically
       h_errno) and returns the corresponding message string.

       The domain name queries carried out  by  gethostbyname()  and  gethost‐
       byaddr() use a combination of any or all of the name server named(8), a
       broken out line from /etc/hosts, and the  Network  Information  Service
       (NIS  or  YP),  depending  upon  the  contents  of  the  order  line in
       /etc/host.conf.  (See resolv+(8)).  The  default  action  is  to  query
       named(8), followed by /etc/hosts.

       The hostent structure is defined in <netdb.h> as follows:

              struct hostent {
                      char    *h_name;        /* official name of host */
                      char    **h_aliases;    /* alias list */
                      int     h_addrtype;     /* host address type */
                      int     h_length;       /* length of address */
                      char    **h_addr_list;  /* list of addresses */
              }
              #define h_addr  h_addr_list[0]  /* for backward compatibility */

       The members of the hostent structure are:

       h_name The official name of the host.

       h_aliases
              A zero-terminated array of alternative names for the host.

       h_addrtype
              The type of address; always AF_INET or AF_INET6 at present.

       h_length
              The length of the address in bytes.

       h_addr_list
              A  zero-terminated  array  of  network addresses for the host in
              network byte order.

       h_addr The first address in h_addr_list for backward compatibility.
-------------------------------------------------------------------------------
NAME
       getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent
       - get protocol entry

SYNOPSIS
       #include <netdb.h>

       struct protoent *getprotoent(void);

       struct protoent *getprotobyname(const char *name);

       struct protoent *getprotobynumber(int proto);

       void setprotoent(int stayopen);

       void endprotoent(void);

DESCRIPTION
       The getprotoent() function reads the next line from the file  /etc/pro‐
       tocols  and  returns  a  structure  protoent  containing the broken out
       fields from the line.  The /etc/protocols file is opened if  necessary.

       The getprotobyname() function returns a protoent structure for the line
       from /etc/protocols that matches the protocol name name.

       The getprotobynumber() function returns a protoent  structure  for  the
       line that matches the protocol number number.

       The  setprotoent()  function opens and rewinds the /etc/protocols file.
       If stayopen is true (1), then the file will not be closed between calls
       to getprotobyname() or getprotobynumber().

       The endprotoent() function closes /etc/protocols.

       The protoent structure is defined in <netdb.h> as follows:

              struct protoent {
                      char    *p_name;        /* official protocol name */
                      char    **p_aliases;    /* alias list */
                      int     p_proto;        /* protocol number */
              }

       The members of the protoent structure are:
       p_name The official name of the protocol.

       p_aliases
              A zero terminated list of alternative names for the protocol.

       p_proto
              The protocol number.
-------------------------------------------------------------------------------
NAME
       getservent,  getservbyname, getservbyport, setservent, endservent - get
       service entry

SYNOPSIS
       #include <netdb.h>

       struct servent *getservent(void);

       struct servent *getservbyname(const char *name, const char *proto);

       struct servent *getservbyport(int port, const char *proto);

       void setservent(int stayopen);

       void endservent(void);

DESCRIPTION
       The getservent() function reads the next line from the  file  /etc/ser‐
       vices  and returns a structure servent containing the broken out fields
       from the line.  The /etc/services file is opened if necessary.

       The getservbyname() function returns a servent structure for  the  line
       from  /etc/services that matches the service name using protocol proto.
       If proto is NULL, any protocol will be matched.

       The getservbyport() function returns a servent structure for  the  line
       that  matches  the port port given in network byte order using protocol
       proto. If proto is NULL, any protocol will be matched.

       The setservent() function opens and rewinds the /etc/services file.  If
       stayopen is true (1), then the file will not be closed between calls to
       getservbyname() and getservbyport().

       The endservent() function closes /etc/services.

       The servent structure is defined in <netdb.h> as follows:

              struct servent {
                      char    *s_name;        /* official service name */
                      char    **s_aliases;    /* alias list */
                      int     s_port;         /* port number */
                      char    *s_proto;       /* protocol to use */
              }
       The members of the servent structure are:

       s_name The official name of the service.

       s_aliases
              A zero terminated list of alternative names for the service.

       s_port The port number for the service given in network byte order.

       s_proto
              The name of the protocol to use with this service.
------------------------------------------------------------------------------

******************************************************************************

------------------------------------------------------------------------------
NAME
       send, sendto, sendmsg - send a message on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t send(int s, const void *buf, size_t len, int flags);
       ssize_t  sendto(int  s,  const  void *buf, size_t len, int flags, const
       struct sockaddr *to, socklen_t tolen);
       ssize_t sendmsg(int s, const struct msghdr *msg, int flags);

DESCRIPTION
       The system calls send, sendto, and sendmsg are used to transmit a  mes‐
       sage to another socket.

       The  send call may be used only when the socket is in a connected state
       (so that the intended recipient is known).  The only difference between
       send  and  write  is the presence of flags.  With zero flags parameter,
       send is equivalent to write.  Also, send(s,buf,len)  is  equivalent  to
       sendto(s,buf,len,NULL,0).

       The parameter s is the file descriptor of the sending socket.

       If  sendto  is  used on a connection-mode (SOCK_STREAM, SOCK_SEQPACKET)
       socket, the parameters to and tolen are ignored (and the error  EISCONN
       may  be  returned when they are not NULL and 0), and the error ENOTCONN
       is returned when the socket was not actually connected. Otherwise,  the
       address  of  the  target is given by to with tolen specifying its size.
       For sendmsg, the address of the target is given by  msg.msg_name,  with
       msg.msg_namelen specifying its size.

       For  send  and  sendto, the message is found in buf and has length len.
       For sendmsg, the message is pointed to by the  elements  of  the  array
       msg.msg_iov.  The sendmsg call also allows sending ancillary data (also
       known as control information).

       If the message is too long to pass atomically  through  the  underlying
       protocol, the error EMSGSIZE is returned, and the message is not trans‐
       mitted.

       No indication of failure to deliver is implicit  in  a  send.   Locally
       detected errors are indicated by a return value of -1.

       When  the message does not fit into the send buffer of the socket, send
       normally blocks, unless the socket has been placed in non-blocking  I/O
       mode.   In  non-blocking mode it would return EAGAIN in this case.  The
       select(2) call may be used to determine when it  is  possible  to  send
       more data.

------------------------------------------------------------------------------
NAME
       recv, recvfrom, recvmsg - receive a message from a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>

       ssize_t recv(int s, void *buf, size_t len, int flags);

       ssize_t  recvfrom(int s, void *buf, size_t len, int flags, struct sock‐
       addr *from, socklen_t *fromlen);

       ssize_t recvmsg(int s, struct msghdr *msg, int flags);

DESCRIPTION
       The recvfrom and recvmsg calls are used  to  receive  messages  from  a
       socket,  and  may be used to receive data on a socket whether or not it
       is connection-oriented.

       If from is not NULL, and the underlying protocol  provides  the  source
       address,  this  source address is filled in.  The argument fromlen is a
       value-result parameter, initialized to the size of the  buffer  associ‐
       ated  with  from, and modified on return to indicate the actual size of
       the address stored there.

       The recv call is normally used only on a  connected  socket  (see  con‐
       nect(2)) and is identical to recvfrom with a NULL from parameter.

       All  three routines return the length of the message on successful com‐
       pletion.  If a message is too long  to  fit  in  the  supplied  buffer,
       excess  bytes may be discarded depending on the type of socket the mes‐
       sage is received from (see socket(2)).

       If no messages are available at the socket, the receive calls wait  for
       a message to arrive, unless the socket is nonblocking (see fcntl(2)) in
       which case the value -1 is returned and the external variable errno set
       to EAGAIN.  The receive calls normally return any data available, up to
       the requested amount, rather than  waiting  for  receipt  of  the  full
       amount requested.

       The  select(2)  or poll(2) call may be used to determine when more data
       arrives.
-------------------------------------------------------------------------------

NAME
       write - write to a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count);

DESCRIPTION
       write  writes  up  to  count  bytes  to the file referenced by the file
       descriptor fd from the buffer starting at buf.  POSIX requires  that  a
       read()  which  can  be  proved  to  occur  after a write() has returned
       returns the new data.  Note that not all file systems  are  POSIX  con‐
       forming.
-------------------------------------------------------------------------------
NAME
       read - read from a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);

DESCRIPTION
       read()  attempts to read up to count bytes from file descriptor fd into
       the buffer starting at buf.

       If count is zero, read() returns zero and has  no  other  results.   If
       count is greater than SSIZE_MAX, the result is unspecified.
-------------------------------------------------------------------------------
