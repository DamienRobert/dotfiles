vim: ft=markdownlight

Définitions
===========

(n,k,d): longueur, dimension, distance

On peut détecter d-1 erreurs, décoder au plus (d-1)/2 erreurs (penser à des
balles), et corriger au plus d-1 effacement (en effet la distance d est le
poids minimal d'un mot, et si on efface les 1 d'un mot minimal on ne sait
pas si on a affaire à 00000 ou à ce mot)

Matrice génératrice: G; m est dans le code si combinaison linéaire des
lignes de G
Matrice de parité H; m est dans le code si m.H=0

Borne du singleton
==================

Singleton bound: k+d <= n+1.
http://en.wikipedia.org/wiki/Singleton_bound

https://en.wikipedia.org/wiki/Singleton_bound
Theorem: Let C be a linear [n,k,d] code over \mathbb{F}_q. The following are equivalent:
- C is an MDS code. [ie k+d=n+1]
- Any k columns of a generator matrix for C are linearly independent.
- Any n-k columns of a parity check matrix for C are linearly independent.
  [en effet la distance c'est le nombre minimal de colonnes dépendentes
  dans la matrice de parité]
- C^{\perp} is an MDS code.
- If G = (I|A) is a generator matrix for C in standard form, then every square submatrix of A is nonsingular.
- Given any d coordinate positions, there is a (minimum weight) codeword whose support is precisely these positions.

Code de Hamming de longueur 7
=============================

m=(x1 x2 x3 x4 p1 p2 p3)
G=(
1 0 0 0 0 1 1
0 1 0 0 1 0 1
0 0 1 0 1 1 0
0 0 0 1 1 1 1
)
On en déduit que p1=x2+x3+x4 (regarder dans la colone p1 l'indice des
lignes pour lesquelles p1=1), p2=x1+x3+x4 et p3=x1+x2+x4 d'où
H=(
0 1 1 1 1 0 0
1 0 1 1 0 1 0
1 1 0 1 0 0 1
)
On vérifie que H*t_G = 0_3 et G*t_H=0_4
On retrouve par exemple que (1 0 0 0 0 1 1) est dans le code: à la colonne
x1 regarder les lignes telles que x1=1

Exemples
========

- Hamming: http://en.wikipedia.org/wiki/Hamming_code
- Reed Solomon: http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction
  (Evaluate p of deg < k in n points of a field; d=n-k+1)
- Reed Muller: http://en.wikipedia.org/wiki/Reed%E2%80%93Muller_code
  The Reed–Muller RM(d, r) code of order d and length n = 2r is the code generated by v0 and the wedge products of up to r of the vi.
  [Code donné par des sous sous-espaces affines]
- Goppa: http://en.wikipedia.org/wiki/Goppa_code
  Evaluate L(D) on n points P_i (distinct from the support), D divisor of the curve G
  k=L(D)-L(D-\sum P_i); d>=n-deg(D)
- Cyclic code: they are ideals in \Fq[x]/(x^n-1) so since the ideals are
  principal they are generated by a polynomial f(x) in this ring.
  Ex: Hamming avec f(x)=x^3+x+1
