Y:f -> f(Y(f)) [dans un langage paresseux], ie
Y(f)=f(x \to Y(f)(x)) [dans un langage strict]
    =x \to f(Y(f))(x)
where f takes a function to a function
and Y(f) is the fixed point of f.

See: http://mvanier.livejournal.com/2897.html for a detailled explanation,
or https://gist.github.com/deepakjois/2689336 with examples in ruby.

[Implems:]
http://rosettacode.org/wiki/Y_combinator#Ruby
~~~ ruby
#cheating
y = lambda do |f|
  lambda {|*args| f[y[f]][*args]}
end

#lambda
y = ->(f) {->(g) {g.(g)}.(->(g) { f.(->(*args) {g.(g).(*args)})})}
fac = ->(f) { ->(n) { n < 2 ? 1 : n * f.(n-1) } }
p 10.times.map {|i| y.(fac).(i)}
fib = ->(f) { ->(n) { n < 2 ? n : f.(n-2) + f.(n-1) } }
p 10.times.map {|i| y.(fib).(i)}

#methods
def y(&f)
  lambda do |g|
    f.call {|*args| g[g][*args]}
  end.tap {|g| break g[g]}
end
fac = y {|&f| lambda {|n| n < 2 ? 1 : n * f[n - 1]}}
fib = y {|&f| lambda {|n| n < 2 ? n : f[n - 1] + f[n - 2]}}
p Array.new(10) {|i| fac[i]}
# => [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
p Array.new(10) {|i| fib[i]}
# => [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
~~~
