The object model
================

In ruby, everything is an object, and every object has a class (accessible
via `Kernel#class`). In particular, a class is an object, of class `Class`.
A class can also have ancestors (accessible via the method
`Module#ancestors`) which are used for method lookup.

For instance, Class ancestors are:
~~~ ruby
Class.ancestors #=> [Class, Module, Object, Kernel, BasicObject]
~~~

Every object `foo` also has a singleton class (also called eigenclass or
metaclass), accessible via `Kernel#singleton_class`. In the inheritance
chain, `foo.singleton_class` is the first class looked-up, before
`foo.class`. 

~~~ ruby
foo="foo"
def foo.bar
  return self+"bar"
end
foo.bar #=> "foobar"
"bar".bar #=> raises NoMethodError
~~~

Actually, if foo is a class, then before the class `Class` the
whole hierarchy of `foo.ancestors` singleton classes are added before in
the inheritance chain.

~~~ ruby
class Foo
  def self.foo
    "foo"
  end
end
class Bar < Foo
end
Bar.foo #=>"foo"
~~~

Classes, modules, virtual classes, proxy classes
------------------------------------------------

The singleton classes are marked as virtual classes in MRI. Virtual classes
are not returned by methods such as class, superclass or ancestors. The
reason is that for efficiency, singleton classes are only generated when
needed (for instance when using `foo.instance_eval` or defining a singleton
method on foo). So until they are explicitely generated by MRI, they are
only virtually in the inheritance chain.

A little confusing bit of ruby's object model is that modules look a lot
like classes (that can't be instancied), but they are actually quite
different:
- a class cannot have a module as a superclass
- a module or a class can only include a module, not a class
In other words, they both use set up their inheritance chain in different
ways: modules use include and classes use superclasses.

The link between both models is done when you _include a module in a
class_. For instance, with `Foo.send(:include,Bar)` then between the class
Foo and its superclass, proxy classes are inserted for each module in the
inheritance chain of the module Bar (except for the modules whose proxy
class are already in the inheritance chain of Foo).

~~~ ruby
module Foo
  def foo
    "foo in Foo"
  end
end
module Bar
  include Foo
  def bar
    "bar in Bar"
  end
end

class A
  include Foo
  def foo
    "foo in A "
  end
  def bar
    "bar in A"
  end
end
class B < A
  include Bar
end
class C
  include Bar
end

B.new.foo #=> "foo in A"
B.new.bar #=> "bar in Bar"
B.ancestors #=> [B, Bar, A, Foo, Object, Kernel, BasicObject]
C.ancestors #=> [C, Bar, Foo, Object, Kernel, BasicObject]
~~~

In this example, including Bar in Foo does not include Foo between B and A,
only Bar, because the proxy class for Foo is already present in the
inheritance chain of B.

A proxy class is like a pointer to the module, it is not a copy. 
So in the following, I will use the C notation &Bar to note the proxy class
of the module Bar.

~~~ ruby
module Foo
end
module Bar
  def bar
    "bar"
  end
end
class A
  include Foo
end
module Foo
  include Bar
  def foo
    "foo"
  end
end
A.new.foo #=> "foo"
A.new.bar #=> raises NoMethodError
A.ancestors #[A, Foo, Object,  Kernel, BasicObject]
class A
  include Foo
end
A.new.bar #=>"bar"
A.ancestors #[A, Foo, Bar, Object,  Kernel, BasicObject]
~~~

A.new.foo works because it is found in the proxy class Foo. The first
A.new.bar does not work because Bar is included in Foo after that Foo is
included in A, so the proxy class &Bar is not in the inheritance chain of
A. This is known as the double include problem, but it can be solved by
including Foo in A again.

Note that `Class#superclass` skips the proxy classes but `Module#ancestors`
will show them, or more precisely it will show the Module they point to.

Now lets go back to our singleton class example:

~~~ ruby
class Foo
  def self.foo
    "foo"
  end
end
class Bar < Foo
end
Bar.foo #=>"foo"
~~~

Why does this work? The inheritance chain of Bar is
[Foo,Object,&Kernel,BasicObject]. So the inheritance chain of
`Bar.singleton_class` is
[#Bar,#Foo,#Object,#&Kernel,#BasicObject,Class,Module,Object,Kernel,BasicObject]
Here I use ruby's notation for printing singleton class, so Bar's
singleton class is noted as #Bar.

Note that since singleton class are marked as virtual classes, they don't
appear in `Module#ancestors`:
Bar.singleton_class.ancestors #=> [Class, Module, Object, Kernel, BasicObject]

Now here is the last piece of the puzzle: #&Kernel is the singleton class
of the proxy class &Kernel. This is not the same as the singleton class of
Kernel! So this does not work

~~~ ruby
module Kernel
  def self.baz
    "baz"
  end
end
Object.baz #=> Raise NoMethodError
~~~

So in practice, the inheritance chain of the singleton class of a class Foo
will only consists of Foo's ancestors that come from classes and not
modules.

If you are wondering, if a Class Bar has a singleton class #Foo in the
inheritance chain, then Bar's singleton class will include #Foo singleton
class (=##Foo) in the inheritence chain.

~~~ ruby
Foo=Class.new
Foo.singleton_class.singleton_class.send(:define_method,:foo) { "foo" }
class Bar < Foo; end
Bar.singleton_class.foo #=> bar
~~~

In this exemple, #Bar's singleton class has for inheritence chain
[##Bar,##Foo,##Object,##&Kernel,##BasicObject,Class,Module,Object,Kernel,BasicObject]

States in ruby
==============

The four context states
-----------------------

Ruby has four states: *self*, *klass*, *cref*, and the *binding* (or scope).

- *self*: the object were functions without specifiers are called.
  You can access it via the keyword `self`.
  ~~~ ruby
  class Foo
    def foo
      puts "In foo self is #{self}"
      bar #will call bar on self
    end
    def bar
      puts "In bar self is #{self}"
    end
  end
  Foo.new.foo 
  #-> In foo self is #<Foo:0xb05818c>
  #-> In bar self is #<Foo:0xb05818c>
  ~~~

  Note: how does ruby distinguish from a function to call on self and a
  local variable?

- *klass*: where functions defined by `def` are defined.
  This is called the default definee in http://yugui.jp/articles/846

  ~~~ ruby
  class Foo
    def foo
      def bar #klass is Foo here
        puts "In bar"
      end
    end
  end
  a=Foo.new
  b=Foo.new
  a.foo #this defines bar for all objects of class Foo
  b.bar
  ~~~

  klass is implicit, you can't access it in ruby. Most of the time (ie if
  not inside an instance/class_eval block), you can access it via
  `Module.nesting.first`.

  *Warning* klass is only used for the keyword `def`. It is not used for `Module#define_method`, which is a method, and works on `self`.
  
  ~~~ ruby
  class Foo
  end
  class Bar
    def Foo.foo #This defines a method in Foo.singleton_class
       def bar #This defines a method in klass=Bar
         puts "bar"
       end
       define_method :baz do #This defines a method in self=Foo
         puts "baz"
       end
       puts "foo!"
    end
  end
  Foo.foo
  Bar.new.bar
  Foo.new.baz
  ~~~

- *cref*: this is the context that permits ruby to find the correct reference
to a constant.

  First ruby tries a lexical approach: it goes through Module.nesting

  ~~~ ruby
  module A
    FOO="foo"
    module B
      puts FOO #::A::FOO
    end
  end
  ~~~

  If this does not work, ruby then tries a dynamical approach: it goes
  through Module.nesting.first.ancestors.

  ~~~ ruby
  class A
    FOO="foo"
    BAR="bar"
  end
  module B
    BAR="foobar"
    class C < A
      puts FOO #::A::FOO
      puts BAR #::B::FOO
    end
  end
  ~~~

  Note: the algorithm for constant finding changed between 1.8, 1.9.1, 1.9.2 and 1.9.3 [http://jfire.io/blog/2011/01/21/making-sense-of-constant-lookup-in-ruby/].

- *binding*: binding refers to the stack of current local variables. It can be accessed via the method `Kernel#binding`.

 *Remark:* binding only concerns local variables. Instance variables like
`@foo` are linked to `self`. Class variables like `@@foo` are linked to
`self.class` except when self is already a class in which case it is linked
to `self`. Global variables like `$foo` are global (sic!). Finally, for
constants like 'Foo' see `cref` above for the constant look-up.

Changing the states
-------------------

- *self*: self is changed when calling a function on an object. See this
example by Yugui:
 
~~~ ruby
class Foo
  def bar(a = self)
    puts a
  end
end
foo = Foo.new
puts foo                       #  displays Foo:0xba5f2c0
foo.bar                        #  displays Foo:0xba5f2c0
~~~

`self` is also changed after the keywords `class`, `module` and the
methods `Kernel#instance_eval` and `Module#class_eval`.

~~~ ruby
module Foo
  p self #Foo
end
p self #main
Foo.instance_eval do
  p self #Foo
end
~~~

- *klass*: klass is changed after the keyword `class` and `module`, where
it is set to the current class/module.
In an_object.instance_eval, klass is set to an_object.singleton_class.
In a_module.class_eval, klass is set to a_module.

 *Note:* in Ruby 1.8 klass in instance_eval is a bit strange. It is set to
an_object.singleton_class, but inside a method klass is based on the
lexically outer class definition. See this example by yugui: on ruby
1.9/2.0 we have:

~~~ ruby
class Foo
  $bar = Object.new
  $bar.instance_eval do
    def hoge(a = (def fuga; end))
      def piyo; end
    end
  end
end
$bar.singleton_methods #=> [:hoge, :fuga, :piyo]
Foo.instance_methods #=>[]
~~~

But in ruby 1.8 we would have
$bar.singleton_methods #=> [:hoge]
Foo.instance_methods #=> [:fuga, :piyo]

- cref: cref is changed by the keywords class and module

~~~ ruby
class Foo
  Module.nesting #=> [Foo]
  class Bar
    Module.nesting #=> [Foo::Bar,Foo]
  end
end
class Foo::Bar
  Module.nesting #=>[Foo::Bar]
end
~~~

The methods `Module.new`, `Class.new` do not change cref.
~~~ ruby
Foo=Class.new do
  p Module.nesting #=> []
  class Bar
    p Module.nesting #=> [Bar]
  end
end
~~~

- *binding*: 
A block, lambda or Proc.new creates a closure. (But remember that the
binding holds references to the objects, so it keeps a frozen copy of the
references, but then the objects can still change when used inside the
closure):

~~~ ruby
a=0; b=0
l=lambda {|x| b=x; a+x }
a=2
l(1) #=> 3
b #=> 1
~~~

The keywords `class`, `module`, `def` create a new binding.

~~~ ruby
a=0
def foo
  a=1
end
foo
a #=> 0
~~~

However, since `Module#define_method` takes a block, by using it instead of
`def` you can use the variables of the current binding in the method
definition, because they will be in the closure of the block.
You can even share a variable between methods by wrapping them around a
lambda to put them in the same closure!

~~~ ruby
l=lambda do
  a=nil
  define_method :set do |x|
    a=x
  end
  define_method :get do
    a
  end
end.call
set(1)
get #=> 1
a #=> raises NameError
~~~

Finally, the keywords while, for, until and if do not introduce a new scope!

~~~ ruby
defined? zorglub #=> nil
a=0...3
for i in a do
  zorglub ||= "zorglub"
  zorglub << i.to_s
end
zorglub #=> zorglub012
~~~

Note: in ruby 1.8 they would introduce a closure.

Top level
---------

In the top level, self is an object called `main`, of class Object.
klass is Object, and cref is [] which means [::]

Note that `main` has singleton methods include, public, private, that
allow in part to work on the top level as if we were inside `class
Object`.

Note: they are there but don't appear in self.singleton_methods in Ruby 2.0,
but they would appear in Ruby 1.9.3.

References
==========

On the top level: [http://banisterfiend.wordpress.com/2010/11/23/what-is-the-ruby-top-level/]

On klass: [http://yugui.jp/articles/846]

On constant lookup: [cirw.in/blog/constant-lookup]

On the double include problem, virtual and proxy classes [https://www.ruby-forum.com/topic/571597#966293]
