Une monade est un couple de foncteurs adjoings F et G:
Theta_AB: Hom(FA,B) \iso Hom(A,GB).

En particulier, on a un morphisme eta qui a A associe 1_FA \in Hom(FA,FA)
-> Hom(A,GFA), donc eta_A est une map A -> GFA. Et on a Theta_AB(h) =
(Gh)eta_A (Pr: A->GFA -(Gh)-> GB)

Donc une manière  de voir ça est que eta_A est la flêche universelle de A
vers un objet de la forme GB, ie si f est une flêche de A -> GB, il existe
une unique g:FA->B telle que
A -f-> GB
|   /
v  / Gg
GFA

D'où une autre définition possible:
si sigma est la counité: sigma_B: FGB-> B, on a
F -Feta-> FGF -sigmaF-> F = 1_F et
G -etaG-> GFG -Gsigma-> G = 1_G (inversement, eta et sigma satisfaisant ces
propriétés donnent une adjonction)


Liens avec Haskell:
return: A -> GF A c'est eta (ex: élément a -> [a])
fmap: f -> GF f c'est le foncteur GF (ex: une fonction A -> B donne une
liste de A -> une liste de B)
join: GFGF A -> GF A c'est GespilonF (ex: une liste de liste -> une liste)

>>= (bind) c'est à m=GFA et g=(A->GFB) l'application 
GFA -GFg -> GFGFB -join-> GFB, ie join(GFg(m))
(ex: une liste de A et une fonction A -> liste de B donne une liste de B)

Exemple en IO:

type IO a  =  RealWorld -> (a, RealWorld)

(>>=) :: IO a -> (a -> IO b) -> IO b
(action1 >>= action2) world0 =
   let (a, world1) = action1 world0
          (b, world2) = action2 a world1
             in (b, world2)

Continuations:
=============
http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style

add_cps :: Int -> Int -> (Int -> r) -> r
add_cps x y k = k (add x y)
square_cps :: Int -> (Int -> r) -> r
square_cps x k = k (square x)
pythagoras_cps :: Int -> Int -> (Int -> r) -> r
pythagoras_cps x y k =
 square_cps x $ \x_squared ->
  square_cps y $ \y_squared ->
   add_cps x_squared y_squared $ \sum_of_squares ->
    k sum_of_squares

newtype Cont r a = Cont { runCont :: (a -> r) -> r }
import Control.Monad.Cont
add_cont :: Int -> Int -> Cont r Int
add_cont x y = return (add x y)
square_cont :: Int -> Cont r Int
square_cont x = return (square x)
pythagoras_cont :: Int -> Int -> Cont r Int
pythagoras_cont x y =
    do x_squared <- square_cont x
       y_squared <- square_cont y
       sum_of_squares <- add_cont x_squared y_squared
       return sum_of_squares

square_C :: Int -> Cont r Int
square_C x = return (x ^ 2)
addThree_C :: Int -> Cont r Int
addThree_C x = return (x + 3)
main = runCont (square_C 4 >>= addThree_C) print
{- Result: 19 -}

The Monad instance for (Cont r) is given below:
instance Monad (Cont r) where
  return n = Cont (\k -> k n)
    m >>= f  = Cont (\k -> runCont m (\a -> runCont (f a) k))
So return n is a Cont-value that throws n straight away into whatever
continuation it is applied to. m >>= f is a Cont-value that runs m with
the continuation \a -> f a k, which maybe, receive the result of
computation inside m (the result is bound to a) , then applies that
result to f to get another Cont-value. This is then called with the
continuation we got at the top level (the continuation is bound to k);
in essence m >>= f is a Cont-value that takes the result from m,
applies it to f, then throws that into the continuation.

callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
           ^^^^^^^^^^^^^^     ^^^^^^^^ 
            continuation k     résultat de f
callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k

Example: square using callCC
-- Without callCC
square :: Int -> Cont r Int
square n = return (n ^ 2)
-- With callCC
square :: Int -> Cont r Int
square n = callCC $ \k -> k (n ^ 2)


