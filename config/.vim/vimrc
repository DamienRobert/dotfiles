" vim: set foldmethod=marker:

" Bundles et fonctions  {{{
filetype plugin on "ftplugin
filetype indent on "ftindent

function! LoadAllBundles(...)
  "vim --startuptime vim.log "for benchmarking
  let reload =  a:0 >= 1  ?  a:1  : 0
  set spell spelllang=fr,en 
  let g:vimball_home=expand("~/.vim/vim-script/vimball")
  if filereadable(expand("~/.vim/bundle/vim-pathogen/autoload/pathogen.vim"))
    runtime bundle/vim-pathogen/autoload/pathogen.vim
    call pathogen#infect()  "les modules dans bundle
    call pathogen#infect('~/.vim/vim-script/colorscheme/{}') "je mets les colorscheme là
    "Appeler :Helptags pour mettre à jour les tags
  endif
  if reload
    echo "Loading all bundles; Use bufdo/windo e to refresh"
    runtime! plugin/*.vim "load plugins
    "silent bufdo e "reedit all files in windows
  endif
endfunction
function! LoadExtraBundles(...)
  let reload =  a:0 >= 1  ?  a:1  : 0
  if filereadable(expand("~/.vim/bundle/vim-pathogen/autoload/pathogen.vim"))
    runtime bundle/vim-pathogen/autoload/pathogen.vim
    call pathogen#infect('~/.vim/vim-script/extrabundle/{}') 
  endif
  if reload
    echo "Loading extra bundles; Use bufdo/windo e to refresh"
    runtime! plugin/*.vim "load plugins
  endif
endfunction
if expand($VIMFAST) != 'true'
  call LoadAllBundles(0) "si on utilise vim, on charge tous les plugins
endif

command! DiffOriginal vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

":Underline - pour underliner with -
function! s:Underline(chars)
  let chars = empty(a:chars) ? '-' : a:chars
  let nr_columns = virtcol('$') - 1
  let uline = repeat(chars, (nr_columns / len(chars)) + 1)
  put =strpart(uline, 0, nr_columns)
endfunction
command! -nargs=? Underline call s:Underline(<q-args>)

if exists("*yankstack#setup")
  call yankstack#setup() "à appeler avant toute map utilisant yank
endif

runtime digraphs.vim " les digraphes de ^
runtime statusline.vim
" }}}

" Options {{{
set backup backupdir=$HOME/.vim_backup,.
if version>=703
  set undofile undodir=$HOME/.vim_backup,.
endif
set directory=$HOME/.vim_backup,.

if has("wildmenu") " Complétion des fichiers
  set wildmenu
endif
set wildmode=list:longest,full
set completeopt+=longest
" La complétion automatique ignore les fichiers suivants. Use wildignore to ignore them completly
set suffixes+=.aux,.dvi,.log,.toc,.tof
set suffixes+=.o,.out,.obj,.git,.rbc,.rbo,.class,.svn,.gem "output and VCS files
set suffixes+=.zip,.tar.gz,.tar.bz2,.rar,.tar.xz "archive files

set undolevels=4000 
set timeout timeoutlen=3000 ttimeoutlen=100
set switchbuf+=useopen
set matchpairs+=<:>
set virtualedit=block display=lastline
set ruler laststatus=2 showmatch showcmd
set shortmess=IfilnrxoOt
set encoding=utf-8 history=50 isprint=@,160-255
set ttyfast modeline nodigraph hidden visualbell
set hlsearch incsearch ignorecase smartcase
set backspace=indent,eol,start
set nojoinspaces " En français, on ne met qu'une espace simple en fin de phrase.
set autoindent textwidth=75 shiftwidth=2
set expandtab smarttab
set kp=viewdoc "pour ne pas faire un conflit entre :ViewDoc et :Man
" Les touches qui font passer à la ligne suivante/précédente. backspace (b), espace (s), flèches (<,>,[,]).
set whichwrap=b,s,<,>,[,],h,l "set whichwrap=b,s,<,>,[,]
"smarttab: un tab en debut de ligne ne donne pas tabstop ' ' mais shiftwidth ' '
"softtabstop c'est le nombre d'espace que donne un Tab quand on le rentre
""tabstop la vraie valeur d'une tab
"set softtabstop=2 tabstop=2
"set shiftround "indent sur un multiple de shiftwidth

"set lazyredraw " Pour éviter de trop ralentir en faisant défiler le texte.
"set viminfo= "forget the informations
set list
set listchars=tab:•·,trail:˙,extends:>,precedes:<,nbsp:×
set showbreak=˻
"ex: Unsec:  Tab:	
"set listchars=eol:¶

set formatoptions+=n2corqlt
" t, c: formater le texte et les commentaires
" q: autoriser gq
" n: bien formater les listes
" or: dans un commentaire, un retour à la ligne continue le commentaire
" -> j'enlève le o, c'est pénible en fait (en fait il faut juste apprendre
"        à faire O sur un non commentaire)
" 2: lors du formatage d'un paragraphe, se base sur la deuxième ligne pour connaitre l'indentation

" réglage de la souris pour gvim
set mousemodel=popup_setpos 
"set mouse=vic " on active la souris dans les terminaux en mode v,i,c
set mouse=a " on active la souris dans les terminaux
"when using visual select, update X11 Primary selection (should be on by defaut, but this is not the case at 'imb')
set clipboard+=autoselect
set guioptions+=a "same for gui
"}}}

" Indentation  {{{
set cino+=n1s "extra indentation pour les if inlines
set cino+=l1 "indentation des case sur le case et pas le label
set cino+=(0u0U1W2s "alignement des parenthèses non fermées
set cino+=j1J1 "compatibilité java
set cino+=#1 "commentaires perl/shell
"}}}

" Les autocommandes  {{{
augroup myaucmd
autocmd!

autocmd Filetype tex compiler tex " pour dire qu'un fichier tex est par defaut du latex et pas du plain tex
autocmd FileType mail setlocal fo-=o

autocmd BufNewFile,BufRead mutt*[0-9] setlocal nobk " Pas de backup des fichiers temporaires de mail faits par mutt dans /tmp:
autocmd BufRead,BufNewFile .article.* setlocal ft=mail nobk "forum
autocmd BufRead,BufNewFile *.tex.latexmain setlocal ft=vim " latexsuite
autocmd BufRead,BufNewFile *.m setlocal ft=magma "magma
autocmd BufRead,BufNewFile *.kramdown setlocal ft=markdown

autocmd BufRead,BufNewFile */.zsh/completion/* setlocal ft=zsh
autocmd BufRead,BufNewFile */avisogenies*/*.m setlocal foldmethod=expr foldexpr=MyMagmaFoldExpr(v:lnum) 
autocmd BufRead,BufNewFile */doc/ruby/* map <leader>shl :call SyntaxRange#Include('@begin=ruby@', '@end=ruby@', 'ruby', 'NonText')<Enter> "ruby doc
autocmd BufRead,BufNewFile */var/dist/pari/* setlocal tags+=$HOME/var/dist/pari/src/tags
autocmd BufRead,BufNewFile */.git/*,*/dist/git/*,.gitconfig setlocal noexpandtab tabstop=2

" Source .vimrc when I write it.  The nested keyword allows
" autocommand ColorScheme to fire when sourcing ~/.vimrc.
au BufWritePost .vimrc nested source $MYVIMRC

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
" Also don't do it when the mark is in the first line, that is the default
" position when opening a file.
" Rem: the package lastpos does that too, it works a bit better for evim
autocmd BufReadPost *
  \ if line("'\"") > 1 && line("'\"") <= line("$") |
  \   exe "normal! g`\"" |
  \ endif

"http://dominique.pelle.free.fr/.vimrc.html
"if version >= 700 && has('autocmd')
"  " Undo break if I don't press a key in insert mode for a few seconds.
"  au! CursorHoldI * call feedkeys("\<C-G>u", "nt")
"endif
augroup END

" vim -b : edit binary using xxd-format " See :help hex-editing
augroup Binary
  au!
  au BufReadPre   *.dat let &bin=1
  au BufReadPost  *.dat if  &bin   | %!xxd
  au BufReadPost  *.dat set ft=xxd | endif
  au BufWritePre  *.dat if  &bin   | %!xxd -r
  au BufWritePre  *.dat endif
  au BufWritePost *.dat if  &bin   | %!xxd
  au BufWritePost *.dat set nomod  | endif
augroup END
" }}}

" Syntax highlight {{{
"set background=light
let g:lucius_style="light"
syntax sync fromstart
syntax enable

augroup EnableSyntaxHighlighting
  au! VimEnter * syntax enable
  "sinon le syntax se fait disabler quand je change de buffers, aucune idée de pourquoi
"http://stackoverflow.com/questions/10513583/filetype-setting-lost-after-reloading-all-files-in-buffer
" Enable syntax highlighting when buffers were loaded through :bufdo, which
" disables the Syntax autocmd event to speed up processing.
    " Filetype processing does happen, so we can detect a buffer initially
    " loaded during :bufdo through a set filetype, but missing b:current_syntax.
    " Also don't do this when the user explicitly turned off syntax highlighting
    " via :syntax off.
    " Note: Must allow nesting of autocmds so that the :syntax enable triggers
    " the ColorScheme event. Otherwise, some highlighting groups may not be
    " restored properly.
    autocmd! BufWinEnter * nested if exists('syntax_on') && ! exists('b:current_syntax') && ! empty(&l:filetype) | syntax enable | endif

    " The above does not handle reloading via :bufdo edit!, because the
    " b:current_syntax variable is not cleared by that. During the :bufdo,
    " 'eventignore' contains "Syntax", so this can be used to detect this
    " situation when the file is re-read into the buffer. Due to the
    " 'eventignore', an immediate :syntax enable is ignored, but by clearing
    " b:current_syntax, the above handler will do this when the reloaded buffer
    " is displayed in a window again.
    autocmd! BufRead * if exists('syntax_on') && exists('b:current_syntax') && ! empty(&l:filetype) && index(split(&eventignore, ','), 'Syntax') != -1 | unlet! b:current_syntax | endif
augroup END

"if &term =~ '^xterm\|^rxvt\|^gnome' || expand("$COLORTERM") =~ '^screen-256color\|^gnome-terminal'
if &t_Co == 256
  "set t_Co=256 
  colorscheme my256
  let &t_SI = "\033]12;DarkOrange3\007"
  let &t_EI = "\033]12;firebrick3\007"
  au VimLeave * :sil !echo -ne "\033]112\007"
  if &term =~ '^gnome' || expand("$COLORTERM") =~ '^gnome-terminal'
    au VimLeave * :sil !echo -ne "\033]12;firebrick3\007"
  endif
else
  colorscheme minimal
endif
" }}}

"Mappings  {{{
"Rappel: parcourir le tag stack, ^] et ^T
"^I et ^O pour parcourir les jumps
let mapleader = ","
nnoremap <leader>; ,
nnoremap <leader>la :call LoadAllBundles(1)<Enter>
nnoremap <leader>le :call LoadExtraBundles(1)<Enter>
nnoremap <leader>lr :bufdo e<Enter>

" Le BackSpace fonctionne aussi en mode normal.
map <BS> X
map <c-h> X
" La touche Q fonctionne comme dans vim 4
nmap Q gqap
vmap Q gq
"q! to do the original Q mapping
nnoremap q! Q 
" La touche Y fait quelque chose de raisonnable
nmap Y y$
" Les Control-flèches (mapping original: page-up et page-down)
map <S-Up> {
map <S-Down> }
map! <S-Up> <C-O>{
map! <S-Down> <C-O>}
"Ctrl-A permettait de copier ce qui avait déjà été inséré
"Ctrl-E permettait de copier le caractère de la ligne du dessous
" on les remplace par C-\ C-A (les C-\ C-? sont libres)
inoremap <C-\><C-A> <C-A>
inoremap <C-\><C-E> <C-E>
inoremap <C-A> <Home>
inoremap <C-E> <End>
" ces commandes sont libres!
inoremap <C-B>         <Left>
inoremap <C-F>         <Right>
" Make shift-insert work like in Xterm for gvim
noremap <S-Insert> <MiddleMouse>
noremap! <S-Insert> <MiddleMouse>

"I want PageUp/Down to complete the current line, not Up/Down
cnoremap <Up> <PageUp>
cnoremap <Down> <PageDown>
cnoremap <PageUp> <Up>
cnoremap <PageDown> <Down>
"C-A will go at the beginning of the line, C-B will insert all completions
cnoremap <C-A>         <C-B>
cnoremap <C-B>         <C-A>

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>
" pareil pour le retour à la ligne "ça me fait deux <Enter!> avec les
" plugins de vim
"inoremap <Enter> <C-G>u<Enter>

"move through visual lines with down and up
noremap <down> gj
noremap <up>   gk
" gz in command mode closes the current buffer
noremap gz :Kwbd<cr>
" g[bB] in command mode switch to the next/prev. buffer
noremap gb :bnext<cr>
noremap gB :bprev<cr>
" Visually select the text that was last edited/pasted
nnoremap gV `[v`]

"swap char
nnoremap <silent> gsc xph
"swap paragraph
nnoremap gsp {dap}p{
"swap words: 
nnoremap <silent> gsl :<C-U>call TransposeWords('next','follow')<CR>
nnoremap <silent> gsh :<C-U>call TransposeWords('prev','follow')<CR>
nnoremap <silent> gsw :<C-U>call TransposeWords('next','keep')<CR>
nnoremap <silent> gsW :<C-U>call TransposeWords('prev','keep')<CR>
nnoremap <silent> gsp :call SwapColWithBefore()<cr>
nnoremap <silent> gsn :call SwapColWithBehind()<cr>
"unimpaired for lines
nnoremap <silent> gsj ]e
nnoremap <silent> gsk [e
"exchange visual selection with last cut
vmap <silent> gse <Plug>SwapVisualWithCut
""" the three belows are from bundle/visswap
"yank visual selection; and then replace
vmap <silent> gsy <Plug>VisualPreSwap
vmap <silent> gsr <Plug>VisualSwap
"select a block, escape, gss => the block will be copied to the pos of the
"cursor (warning if lines conflict it does strange things)
nmap <silent> gss <Plug>VisualReplace

" Toggle paste mode, marche pour inverser même en mode paste
set pastetoggle=<F12>
nnoremap <F2> :NERDTreeToggle<cr>
nnoremap <F3> :BuffergatorToggle<cr>
nnoremap <F4> :TagbarToggle<cr>
nnoremap <F11> :GundoToggle<cr>

" cd to the directory containing the file in the buffer
nnoremap <silent> <leader>sC :lcd %:h<CR>
" Create the directory containing the file in the buffer
nnoremap <silent> <leader>sM :!mkdir -p %:p:h<CR>
" script de bubu
noremap <leader>sc  "zyl:echom system("unicodeprop.pl '".@z."'")<Enter>
" Tip #99: display syntax group under the cursor.
noremap  ,sk :echo "hi<"
\ . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")
\ . ">"<CR>
" find merge conflict markers (From https://github.com/carlhuda/janus)
nnoremap <silent> <leader>sm <ESC>/\v^[<=>]{7}( .*\|$)<CR>
" Underline the current line with '='
nnoremap <silent> <leader>su :t.\|s/./=/g\|:nohls<cr>

"set text wrapping toggles
nnoremap <silent> <leader>tw :set invwrap<CR>:set wrap?<CR>
"show hidden char toggle
function! ToggleShowbreak()
  if empty(&showbreak)
    set showbreak=˻
  else
    set showbreak=
  endif
endfunction
nnoremap <silent> <leader>tl :set invlist<CR>:call ToggleShowbreak()<CR>:set list?<CR>

"show lines toggle
nnoremap <silent> <leader>tn :set invnumber<CR>:set number?<CR>
noremap <silent> <leader>ts :if exists("g:syntax_on") <Bar> syntax off <Bar> else <Bar> syntax enable <Bar> endif <CR>
nnoremap <leader>/ :nohlsearch<CR>
"Close the quickfix and preview window and location liste
nmap <buffer> <Leader>tq :lcl<CR>:ccl<CR>:pc<CR>

cnoremap %% <C-R>=expand('%:h').'/'<cr>
nmap <leader>ee :e %%
nmap <leader>es :sp %%
nmap <leader>eS :vsp %%
nmap <leader>et :tabe %%
nnoremap <leader>ev :tabedit $MYVIMRC<CR>
nnoremap <silent> <leader>eV :source $MYVIMRC<CR>:filetype detect<CR>:exe ":echo 'vimrc reloaded'"<CR>
" }}}

" old config not used anymore {{{
"imap pour les map dans insert
"map pour les map dans en mode normal et visuel
"n map mode normal
"vmap mode visuel
"cmap pour les map dans la commande

""remettre à jour les helptags:
":helptags ~/.vim/doc 
":Helptags pour prendre en compte les .vim/bundle
"
" Ignore bundler and sass cache
"set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" Disable temp and backup files
"set wildignore+=*.swp,*~,._*

" Options de formatage des fichiers pour le source C.
" "autocmd FileType c,cpp set fo=croq cin com=sr:/*,mb:*,el:*/,://
" " autocmd BufRead,BufNewFile * set formatoptions=tcq2 nocindent

" Colorier les espaces insécables {{{
" cf list, où je fais ça là
"" autocmd ColorScheme * highlight Insecable  ctermfg=darkBlue cterm=underline
"autocmd ColorScheme * highlight Insecable  ctermbg=darkgreen guibg=darkgreen
"autocmd BufRead,BufNewFile * syntax match Insecable / / containedin=ALL
"syntax match Insecable / / containedin=ALL
" }}}

" Le spell highlight
"augroup myaucmd
" Je suis obligé de le faire dans un au sinon en resourçant ça buggue

" Spell 
"autocmd ColorScheme * highlight SpellBad cterm=undercurl ctermfg=none ctermbg=none
"autocmd ColorScheme * highlight SpellLocal cterm=undercurl ctermfg=none ctermbg=none
"autocmd ColorScheme * highlight SpellRare cterm=undercurl ctermfg=none ctermbg=none
"autocmd ColorScheme * highlight SpellCap cterm=none ctermfg=none ctermbg=none

" Malheureusement gnome-term a pour TERM=xterm mais ne connait pas cette séquence :-(
""if &term =~ '^xterm'
""  " solid underscore
""  let &t_SI .= "\<Esc>[4 q"
""  " solid block
""  let &t_EI .= "\<Esc>[2 q"
""  " 1 or 0 -> blinking block
""  " 3 -> blinking underscore
"" Change color of cursor in terminal:
"" - red in normal mode.
"" - orange in insert mode.
"" Tip found there:  http://forums.macosxhints.com/archive/index.php/t-49708.html
" if &term =~ '^xterm\|^rxvt\|^gnome' || expand("$COLORTERM") =~ '^screen-256color\|^gnome-terminal'
"   set t_Co=256 
"   "normally should not be needed
"   "but this is needed by gnome-term and screen
"   "and i can't always detect gnome-term by COLORTERM (because of ssh)
" 
"   "let g:solarized_termcolors=256
"   "let g:solarized_visibility="low"  " list chars 
"   "colorscheme solarized
"   "colorscheme mayansmoke
"   "colorscheme lucius
"   colorscheme my256
" 
"     ":silent !echo -ne "\033]12;firebrick3\007"
"     "au VimEnter * :sil !echo -ne "\033]12;firebrick3\007"
"     let &t_SI = "\033]12;DarkOrange3\007"
"     let &t_EI = "\033]12;firebrick3\007"
"     au VimLeave * :sil !echo -ne "\033]112\007"
"   if &term =~ '^gnome' || expand("$COLORTERM") =~ '^gnome-terminal'
"    au VimLeave * :sil !echo -ne "\033]12;firebrick3\007"
"   "elseif expand("$COLORTERM") =~ 'screen256'
"   "  set t_Co=256
"   endif
" else
"   colorscheme minimal
" endif

"Underline (but use a register, cf the actual map for a better way)
"nnoremap <leader>su "zyy"zp<c-v>$r=
"nmap <silent> <leader>tp :set invpaste<CR>:set paste?<CR>
" Toggle hlsearch with <leader>hs (it is usually simpler to just clean the search)
"nmap <leader>th :set hlsearch! hlsearch?<CR>

""emacs-style editing of the command line:
"" conflicts with new bindinds. Do Ctrl-F to open a window
"" back one character
"cnoremap <C-B>         <Left> 
"" forward one character
"cnoremap <C-F>         <Right> 
"" start of line
"cnoremap <C-A>         <Home>
"" delete character under cursor
"cnoremap <C-D>         <Del>
"" end of line
"cnoremap <C-E>         <End>
"" recall newer command-line
"cnoremap <C-N>         <Down>
"" recall previous (older) command-line
""cnoremap <C-P>         <Up>
"" Insert the current directory into a command-line path
"cmap <C-P> <C-R>=expand("%:p:h") . "/"<CR>

" back one word
"cnoremap <Esc><C-B>    <S-Left>
" forward one word
"cnoremap <Esc><C-F>    <S-Right>
" }}}
